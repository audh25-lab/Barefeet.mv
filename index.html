<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>BarefeetMV ðŸ‘£</title>

  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
  <meta name="theme-color" content="#00e5ff" />

  <!-- PWA -->
  <link rel="manifest" href="/manifest.json" />
  <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMAAAADACAYAAABU1PscAAAACXBIWXMAAAsSAAALEgHS3X78AAAA" />

  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      touch-action: none;
      font-family: system-ui, -apple-system, BlinkMacSystemFont;
    }
    canvas {
      display: block;
    }
    #install {
      position: fixed;
      bottom: 16px;
      right: 16px;
      padding: 10px 14px;
      background: #00e5ff;
      color: #000;
      border-radius: 20px;
      font-size: 14px;
      display: none;
      z-index: 10;
    }
  </style>
</head>

<body>
  <canvas id="c"></canvas>
  <button id="install">Install ðŸ‘£</button>

<script>
/* =========================
   SERVICE WORKER
========================= */
if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("/sw.js");
}

/* =========================
   INSTALL PROMPT
========================= */
let deferredPrompt;
const installBtn = document.getElementById("install");

window.addEventListener("beforeinstallprompt", e => {
  e.preventDefault();
  deferredPrompt = e;
  installBtn.style.display = "block";
});

installBtn.onclick = () => {
  deferredPrompt?.prompt();
};

/* =========================
   CANVAS + AUDIO
========================= */
const c = document.getElementById("c");
const ctx = c.getContext("2d");
const ac = new (window.AudioContext || window.webkitAudioContext)();

/* unlock audio on first touch */
document.addEventListener("pointerdown", () => {
  if (ac.state !== "running") ac.resume();
}, { once: true });

/* =========================
   WORLD STATE
========================= */
let w, h;
const world = {
  size: 4,
  tiles: [],
  particles: [],
  imprints: [],
  undo: [],
  score: 0,
  realm: 1,
  slow: 0,
  high: Number(localStorage.getItem("high") || 0)
};

class Tile {
  constructor(x, y, v) {
    this.x = x;
    this.y = y;
    this.v = v;
    this.vx = 0;
    this.vy = 0;
  }
}

const rand = (a,b)=>Math.random()*(b-a)+a;
const dist = (x1,y1,x2,y2)=>Math.hypot(x2-x1,y2-y1);

function canMerge(a,b){
  return (a===1&&b===1) || ((a===2&&b===1)||(a===1&&b===2)) || (a>=3 && a===b);
}
function mergeVal(a,b){
  if(a===1&&b===1) return 2;
  if(a>=3&&a===b) return a*2;
  return 3;
}

function addTile(){
  world.tiles.push(
    new Tile(
      rand(-world.size/2, world.size/2),
      rand(-world.size/2, world.size/2),
      Math.random()<0.5?1:2
    )
  );
}

function playSound(freq,dur){
  const o=ac.createOscillator();
  const g=ac.createGain();
  o.frequency.value=freq;
  g.gain.value=0.4;
  o.connect(g); g.connect(ac.destination);
  o.start(); setTimeout(()=>o.stop(),dur);
}

function pushUndo(){
  if(world.undo.length>2) world.undo.shift();
  world.undo.push(JSON.stringify(world.tiles));
}
function undo(){
  if(world.undo.length) world.tiles=JSON.parse(world.undo.pop());
}

/* =========================
   BREATH FORCE
========================= */
function applyForce(toward,str){
  for(const t of world.tiles){
    const d=Math.hypot(t.x,t.y)+0.001;
    const fx=(t.x/d)*(toward?-str:str);
    const fy=(t.y/d)*(toward?-str:str);
    t.vx+=fx; t.vy+=fy;
  }
  playSound(toward?180:360,120);
}

/* =========================
   UPDATE
========================= */
function update(){
  if(world.slow>0){ world.slow--; return; }

  for(const t of world.tiles){
    t.x+=t.vx; t.y+=t.vy;
    t.vx*=0.92; t.vy*=0.92;
  }

  const merges=[];
  for(let i=0;i<world.tiles.length;i++){
    for(let j=i+1;j<world.tiles.length;j++){
      const a=world.tiles[i], b=world.tiles[j];
      if(dist(a.x,a.y,b.x,b.y)<0.5 && canMerge(a.v,b.v))
        merges.push([i,j]);
    }
  }

  const used=new Set();
  for(const [i,j] of merges){
    if(used.has(i)||used.has(j)) continue;
    used.add(i); used.add(j);

    const a=world.tiles[i], b=world.tiles[j];
    const v=mergeVal(a.v,b.v);
    world.tiles.push(new Tile((a.x+b.x)/2,(a.y+b.y)/2,v));
    world.score+=v;
    playSound(400+v*4,80);
  }

  world.tiles=world.tiles.filter((_,i)=>!used.has(i));
  if(Math.random()<0.15) addTile();
  world.high=Math.max(world.high,world.score);
  localStorage.setItem("high",world.high);
}

/* =========================
   DRAW
========================= */
function draw(){
  ctx.clearRect(0,0,w,h);
  const s=Math.min(w,h)/world.size*0.8;
  ctx.save();
  ctx.translate(w/2,h/2);
  ctx.scale(s,s);

  for(const t of world.tiles){
    const hue=t.v<=2?200:(Math.log2(t.v)*35)%360;
    ctx.fillStyle=`hsl(${hue},80%,60%)`;
    ctx.beginPath();
    ctx.arc(t.x,t.y,0.25,0,Math.PI*2);
    ctx.fill();
  }

  ctx.restore();
  ctx.fillStyle="#fff";
  ctx.fillText(`Score ${world.score}  High ${world.high}`,10,20);
}

/* =========================
   INPUT
========================= */
let lastD=0;
c.onpointerdown=e=>{
  lastD=Math.hypot(e.clientX-w/2,e.clientY-h/2);
  pushUndo();
};
c.onpointermove=e=>{
  if(e.buttons){
    const d=Math.hypot(e.clientX-w/2,e.clientY-h/2);
    applyForce(d<lastD,Math.abs(d-lastD)/80);
    lastD=d;
  }
};
window.onkeydown=e=>{ if(e.key==="u") undo(); };

/* =========================
   LOOP
========================= */
function resize(){
  w=c.width=innerWidth;
  h=c.height=innerHeight;
}
addTile(); addTile();
resize(); addEventListener("resize",resize);

(function loop(){
  update(); draw();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>